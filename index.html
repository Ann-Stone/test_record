<!doctype html>
<html lang="zh-TW">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>å³æ™‚èªéŸ³ç¿»è­¯å­—å¹•ç³»çµ±</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            }

            .container {
                background: white;
                border-radius: 20px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                padding: 40px;
                max-width: 800px;
                width: 100%;
            }

            h1 {
                text-align: center;
                color: #333;
                margin-bottom: 30px;
                font-size: 28px;
            }

            .config-section {
                background: #f8f9fa;
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
            }

            .config-row {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
                gap: 15px;
                flex-wrap: wrap;
            }

            @media (max-width: 600px) {
                .config-row {
                    flex-direction: column;
                    align-items: stretch;
                    gap: 8px;
                }

                .config-row label {
                    min-width: auto;
                }
            }

            .config-row:last-child {
                margin-bottom: 0;
            }

            label {
                font-weight: 600;
                color: #555;
                min-width: 120px;
            }

            input[type="text"],
            input[type="number"],
            select {
                flex: 1;
                padding: 10px;
                border: 2px solid #ddd;
                border-radius: 8px;
                font-size: 14px;
                transition: border-color 0.3s;
            }

            input[type="text"]:focus,
            input[type="number"]:focus,
            select:focus {
                outline: none;
                border-color: #667eea;
            }

            select {
                cursor: pointer;
                background-color: white;
            }

            .controls {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 30px 0;
            }

            button {
                padding: 15px 40px;
                font-size: 18px;
                font-weight: 600;
                border: none;
                border-radius: 50px;
                cursor: pointer;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            }

            #recordBtn {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }

            #recordBtn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            }

            #recordBtn.recording {
                background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0%,
                100% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
            }

            #stopBtn {
                background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
                color: white;
                display: none;
            }

            #stopBtn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(250, 112, 154, 0.4);
            }

            .status {
                text-align: center;
                padding: 15px;
                border-radius: 10px;
                margin-bottom: 20px;
                font-weight: 600;
            }

            .status.idle {
                background: #e3f2fd;
                color: #1976d2;
            }

            .status.recording {
                background: #fce4ec;
                color: #c2185b;
            }

            .status.processing {
                background: #fff3e0;
                color: #f57c00;
            }

            .status.error {
                background: #ffebee;
                color: #c62828;
            }

            .subtitles {
                background: #f8f9fa;
                border-radius: 10px;
                padding: 20px;
                max-height: 400px;
                overflow-y: auto;
                margin-bottom: 20px;
            }

            .subtitle-item {
                background: white;
                padding: 15px;
                margin-bottom: 10px;
                border-radius: 8px;
                border-left: 4px solid #667eea;
                animation: slideIn 0.3s ease-out;
            }

            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateX(-20px);
                }
                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }

            .subtitle-item:last-child {
                margin-bottom: 0;
                border-left-color: #f5576c;
            }

            .subtitle-item.error {
                border-left-color: #f44336;
            }

            .subtitle-time {
                font-size: 12px;
                color: #888;
                margin-bottom: 5px;
            }

            .subtitle-text {
                font-size: 16px;
                color: #333;
                line-height: 1.6;
            }

            .subtitle-original {
                font-size: 14px;
                color: #666;
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid #eee;
                font-style: italic;
            }

            .subtitle-text.error {
                color: #f44336;
            }

            .info {
                background: #e8f5e9;
                padding: 15px;
                border-radius: 10px;
                margin-top: 20px;
                font-size: 14px;
                color: #2e7d32;
            }

            .info ul {
                margin-left: 20px;
                margin-top: 10px;
            }

            .info li {
                margin-bottom: 5px;
            }

            .warning {
                background: #fff3e0;
                padding: 15px;
                border-radius: 10px;
                margin-top: 15px;
                font-size: 14px;
                color: #e65100;
                border-left: 4px solid #ff9800;
            }

            .warning strong {
                display: block;
                margin-bottom: 8px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ğŸ¤ å³æ™‚èªéŸ³ç¿»è­¯å­—å¹•ç³»çµ±</h1>

            <div class="config-section">
                <div class="config-row">
                    <label>n8n Webhook URL:</label>
                    <input
                        type="text"
                        id="webhookUrl"
                        placeholder="https://your-n8n-instance.com/webhook/upload-notes"
                        value="https://ann-stone.zeabur.app/webhook/upload-notes"
                    />
                </div>
                <div class="config-row">
                    <label>ä¾†æºèªè¨€:</label>
                    <select id="sourceLanguage">
                        <option value="chinese">ä¸­æ–‡</option>
                        <option value="english">è‹±æ–‡</option>
                        <option value="japanese">æ—¥æ–‡</option>
                    </select>
                </div>
                <div class="config-row">
                    <label>åˆ†æ®µæ™‚é–“ (ç§’):</label>
                    <input
                        type="number"
                        id="segmentDuration"
                        value="10"
                        min="3"
                        max="30"
                    />
                </div>
                <div class="config-row">
                    <label>ä¸Šä¸‹æ–‡æ®µæ•¸:</label>
                    <input
                        type="number"
                        id="contextSegments"
                        value="2"
                        min="0"
                        max="5"
                    />
                </div>
            </div>

            <div class="status idle" id="status">æº–å‚™å°±ç·’ - è«‹æŒ‰éŒ„éŸ³é–‹å§‹</div>

            <div class="controls">
                <button id="recordBtn">ğŸ™ï¸ é–‹å§‹éŒ„éŸ³</button>
                <button id="stopBtn">â¹ï¸ åœæ­¢éŒ„éŸ³</button>
            </div>

            <div class="subtitles" id="subtitles">
                <div style="text-align: center; color: #999; padding: 40px">
                    ç¿»è­¯çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º...
                </div>
            </div>

            <div class="info">
                <strong>ğŸ’¡ ä½¿ç”¨èªªæ˜ï¼š</strong>
                <ul>
                    <li>è¨­å®šæ‚¨çš„ n8n Webhook URL</li>
                    <li>èª¿æ•´åˆ†æ®µæ™‚é–“ï¼ˆå»ºè­° 8-15 ç§’ï¼‰</li>
                    <li>
                        ä¸Šä¸‹æ–‡æ®µæ•¸ç”¨æ–¼æä¾›å‰é¢å¹¾æ®µçš„åŸæ–‡çµ¦ Gemini
                        åƒè€ƒï¼Œé¿å…ç¿»è­¯æ–·è£‚
                    </li>
                    <li>æŒ‰ä¸‹éŒ„éŸ³æŒ‰éˆ•é–‹å§‹ï¼Œç³»çµ±æœƒè‡ªå‹•åˆ†æ®µå‚³é€éŸ³æª”</li>
                    <li>ç¿»è­¯çµæœæœƒåƒå­—å¹•ä¸€æ¨£é€æ®µé¡¯ç¤º</li>
                </ul>
            </div>
        </div>

        <script>
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            let segmentTimer;
            let translationHistory = [];
            let segmentCount = 0;
            let requestQueue = [];
            let isProcessingQueue = false;

            const recordBtn = document.getElementById("recordBtn");
            const stopBtn = document.getElementById("stopBtn");
            const status = document.getElementById("status");
            const subtitles = document.getElementById("subtitles");
            const webhookUrl = document.getElementById("webhookUrl");
            const sourceLanguage = document.getElementById("sourceLanguage");
            const segmentDuration = document.getElementById("segmentDuration");
            const contextSegments = document.getElementById("contextSegments");

            recordBtn.addEventListener("click", startRecording);
            stopBtn.addEventListener("click", stopRecording);

            async function startRecording() {
                if (!webhookUrl.value) {
                    alert("è«‹å…ˆè¨­å®š n8n Webhook URLï¼");
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: true,
                    });

                    // æ¸…ç©ºä¹‹å‰çš„è¨˜éŒ„
                    translationHistory = [];
                    segmentCount = 0;
                    requestQueue = [];
                    isProcessingQueue = false;
                    subtitles.innerHTML = "";

                    isRecording = true;
                    recordBtn.style.display = "none";
                    stopBtn.style.display = "inline-block";
                    recordBtn.classList.add("recording");
                    updateStatus("éŒ„éŸ³ä¸­...", "recording");

                    startSegmentRecording(stream);
                } catch (err) {
                    console.error("ç„¡æ³•å­˜å–éº¥å…‹é¢¨:", err);
                    alert("ç„¡æ³•å­˜å–éº¥å…‹é¢¨ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®šï¼");
                }
            }

            function startSegmentRecording(stream) {
                audioChunks = [];

                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, {
                        type: "audio/webm",
                    });

                    // åŠ å…¥ä½‡åˆ—è€Œä¸æ˜¯ç›´æ¥ç™¼é€
                    addToQueue(audioBlob);

                    // å¦‚æœé‚„åœ¨éŒ„éŸ³ç‹€æ…‹ï¼Œç¹¼çºŒä¸‹ä¸€æ®µ
                    if (isRecording) {
                        setTimeout(() => startSegmentRecording(stream), 100);
                    } else {
                        stream.getTracks().forEach((track) => track.stop());
                    }
                };

                mediaRecorder.start();

                // è¨­å®šåˆ†æ®µæ™‚é–“
                const duration = parseInt(segmentDuration.value) * 1000;
                segmentTimer = setTimeout(() => {
                    if (mediaRecorder.state === "recording") {
                        mediaRecorder.stop();
                    }
                }, duration);
            }

            // åŠ å…¥ä½‡åˆ—
            function addToQueue(audioBlob) {
                segmentCount++;
                const queueItem = {
                    audioBlob: audioBlob,
                    segmentNumber: segmentCount,
                    timestamp: new Date().toISOString(),
                };
                requestQueue.push(queueItem);

                // æ›´æ–°ç‹€æ…‹é¡¯ç¤ºä½‡åˆ—æ•¸é‡
                updateStatus(
                    `éŒ„éŸ³ä¸­... (å¾…è™•ç†: ${requestQueue.length} æ®µ)`,
                    "recording",
                );

                // å¦‚æœæ²’æœ‰åœ¨è™•ç†ä½‡åˆ—ï¼Œé–‹å§‹è™•ç†
                if (!isProcessingQueue) {
                    processQueue();
                }
            }

            // è™•ç†ä½‡åˆ—
            async function processQueue() {
                if (requestQueue.length === 0) {
                    isProcessingQueue = false;
                    if (isRecording) {
                        updateStatus("éŒ„éŸ³ä¸­...", "recording");
                    } else {
                        updateStatus(
                            `è™•ç†å®Œæˆ - å…±è™•ç† ${segmentCount} æ®µ`,
                            "idle",
                        );
                    }
                    return;
                }

                isProcessingQueue = true;
                const queueItem = requestQueue.shift();

                await sendAudioToN8n(
                    queueItem.audioBlob,
                    queueItem.segmentNumber,
                    queueItem.timestamp,
                );

                // ç¹¼çºŒè™•ç†ä¸‹ä¸€å€‹
                processQueue();
            }

            async function sendAudioToN8n(audioBlob, segmentNumber, timestamp) {
                updateStatus(
                    `è™•ç†ç¬¬ ${segmentNumber} æ®µéŸ³è¨Š... (å¾…è™•ç†: ${requestQueue.length} æ®µ)`,
                    "processing",
                );

                try {
                    // æº–å‚™ä¸Šä¸‹æ–‡è³‡æ–™
                    const contextCount = parseInt(contextSegments.value);
                    const contextData = translationHistory
                        .slice(-contextCount)
                        .map((item) => item.original);

                    // å°‡éŸ³æª”è½‰ç‚º Base64
                    const base64Audio = await blobToBase64(audioBlob);

                    // ç™¼é€åˆ° n8n - ä½¿ç”¨ç°¡å–®æ¨¡å¼é¿å… preflight
                    const response = await fetch(webhookUrl.value, {
                        method: "POST",
                        headers: {
                            "Content-Type": "text/plain", // ä½¿ç”¨ text/plain é¿å… CORS preflight
                        },
                        body: JSON.stringify({
                            audio: base64Audio,
                            language: sourceLanguage.value,
                            context: contextData,
                            segmentNumber: segmentNumber,
                            timestamp: timestamp,
                        }),
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            displayTranslation(result, segmentNumber);
                            if (isRecording) {
                                updateStatus(
                                    `éŒ„éŸ³ä¸­... (å¾…è™•ç†: ${requestQueue.length} æ®µ)`,
                                    "recording",
                                );
                            }
                        } else {
                            addErrorMessage(
                                `ç¬¬ ${segmentNumber} æ®µè™•ç†å¤±æ•—: ${result.error || "æœªçŸ¥éŒ¯èª¤"}`,
                            );
                        }
                    } else {
                        console.error(
                            "å‚³é€å¤±æ•—:",
                            response.status,
                            response.statusText,
                        );
                        const errorText = await response
                            .text()
                            .catch(() => "ç„¡æ³•è®€å–éŒ¯èª¤è¨Šæ¯");
                        addErrorMessage(
                            `ç¬¬ ${segmentNumber} æ®µå‚³é€å¤±æ•— (HTTP ${response.status})`,
                        );
                    }
                } catch (err) {
                    console.error("ç™¼é€éŒ¯èª¤:", err);
                    let errorMsg = `ç¬¬ ${segmentNumber} æ®µè™•ç†éŒ¯èª¤`;
                    if (err.message.includes("CORS")) {
                        errorMsg += " - CORS éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ n8n è¨­å®š";
                    } else if (err.message.includes("Failed to fetch")) {
                        errorMsg += " - ç¶²è·¯éŒ¯èª¤æˆ– URL ä¸æ­£ç¢º";
                    }
                    addErrorMessage(errorMsg);
                }
            }

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(",")[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            function displayTranslation(result, segmentNumber) {
                // å„²å­˜åˆ°æ­·å²è¨˜éŒ„ - original æ˜¯åŸæ–‡ï¼Œtranslation æ˜¯ç¿»è­¯çµæœ
                translationHistory.push({
                    original: result.original || "", // å„²å­˜åŸæ–‡ç”¨æ–¼ä¸‹æ¬¡ä¸Šä¸‹æ–‡
                    translation:
                        result.translation || result.text || "ç¿»è­¯ä¸­...",
                });

                // é¡¯ç¤ºå­—å¹• - åŒæ™‚é¡¯ç¤ºç¿»è­¯å’ŒåŸæ–‡
                const item = document.createElement("div");
                item.className = "subtitle-item";

                let originalHtml = "";
                // å¦‚æœåŸæ–‡å’Œç¿»è­¯ä¸åŒï¼Œæ‰é¡¯ç¤ºåŸæ–‡
                if (result.original && result.original !== result.translation) {
                    originalHtml = `<div class="subtitle-original">åŸæ–‡: ${result.original}</div>`;
                }

                item.innerHTML = `
                <div class="subtitle-time">${new Date().toLocaleTimeString()} - ç¬¬ ${segmentNumber} æ®µ</div>
                <div class="subtitle-text">ç¿»è­¯ï¼š${result.translation || result.text || "ç¿»è­¯ä¸­..."}</div>
                ${originalHtml}
            `;

                subtitles.appendChild(item);
                subtitles.scrollTop = subtitles.scrollHeight;
            }

            function addErrorMessage(message) {
                const item = document.createElement("div");
                item.className = "subtitle-item error";
                item.innerHTML = `
                <div class="subtitle-time">${new Date().toLocaleTimeString()}</div>
                <div class="subtitle-text error">âŒ ${message}</div>
            `;

                subtitles.appendChild(item);
                subtitles.scrollTop = subtitles.scrollHeight;
            }

            function stopRecording() {
                isRecording = false;
                clearTimeout(segmentTimer);

                if (mediaRecorder && mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                }

                recordBtn.style.display = "inline-block";
                stopBtn.style.display = "none";
                recordBtn.classList.remove("recording");

                // å¦‚æœé‚„æœ‰ä½‡åˆ—åœ¨è™•ç†ï¼Œé¡¯ç¤ºè™•ç†ä¸­ç‹€æ…‹
                if (requestQueue.length > 0 || isProcessingQueue) {
                    updateStatus(
                        `éŒ„éŸ³çµæŸ - è™•ç†å‰©é¤˜ ${requestQueue.length} æ®µ...`,
                        "processing",
                    );
                } else {
                    updateStatus(
                        `è™•ç†å®Œæˆ - å…±è™•ç† ${segmentCount} æ®µ`,
                        "idle",
                    );
                }
            }

            function updateStatus(text, type) {
                status.textContent = text;
                status.className = `status ${type}`;
            }
        </script>
    </body>
</html>
